% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pop_density_polygonise.R
\name{pop_density_polygonise}
\alias{pop_density_polygonise}
\title{Polygonise population density raster to population count per (building) polygon}
\usage{
pop_density_polygonise(
  input_raster,
  write = FALSE,
  dsn,
  driver = "GeoJSON",
  overwrite = TRUE,
  delete_dsn = TRUE,
  ...
)
}
\arguments{
\item{input_raster}{Population density raster as a SpatRaster object (\code{terra::rast()}).
Output from \code{pop_dasymap()} may be used.}

\item{write}{Whether or not to export the output. Defaults to \code{FALSE}.}

\item{dsn}{Argument passed to \code{sf::st_write()}.}

\item{driver}{character. Argument passed to \code{sf::st_write()}. Defaults to \code{'GeoJSON'}.}

\item{overwrite}{logical. Argument passed to \code{sf::st_write()}. Defaults to \code{TRUE}.}

\item{delete_dsn}{Argument passed to \code{sf::st_write()}. Defaults to \code{TRUE}.}

\item{...}{Other arguments passed to \code{sf::st_write()}.}
}
\value{
Building \code{sf }polygons with column \code{popcount}.
}
\description{
Convert raster of population density (e.g. from \code{pop_dasymap()} output) to population count per polygon
(adjacent polygons with similar pixel values are merged).
Thus, if rasters supplied to \code{pop_dasymap()} are at a spatial resolution small enough to delineate individual buildings,
conversion to polygons using this function would reflect the population count per building.
Input data should have a projected coordinate reference system specific to the target area.
}
\examples{
\dontrun{
data(pop_sgp) # population census block polygons
data(landuse_sgp) # land use polygons

# merge all census blocks for chosen year (2020) into single multi-polygon
# function requires that polygons are merged
city_boundaries <- pop_sgp \%>\%
   dplyr::filter(year == 2020) \%>\%
   sf::st_union() \%>\%
   sf::st_as_sf() \%>\%
   smoothr::fill_holes(threshold = units::set_units(1, 'km^2'))  \%>\%
   smoothr::drop_crumbs(threshold = units::set_units(1, 'km^2'))  \%>\%
   sf::st_make_valid()

buildings <- get_buildings_osm(place = city_boundaries,
                               date = as.Date('2021-01-01')) \%>\%
   dplyr::mutate(year = 2020)


# rasterise population, landuse & buildings
pop_rasters <- rasterise_pop(pop_sgp,
                             census_block = "subzone_n",
                             pop_count = "pop_count")

landuse_rasters <- rasterise_landuse(landuse_sgp,
                                     land_use = 'lu_desc',
                                     subset = c('1' = 'RESIDENTIAL',
                                                '2' = 'COMMERCIAL & RESIDENTIAL',
                                                '3' = 'RESIDENTIAL WITH COMMERCIAL AT 1ST STOREY',
                                                '4' = 'RESIDENTIAL / INSTITUTION'),
                                     sf_pop = pop_sgp,
                                     match_landuse_pop = 'recent')

buildings_rasters <- rasterise_buildings(buildings,
                                     proxy_pop_density = 'levels',
                                     year = 'year',
                                     sf_pop = pop_sgp,
                                     sf_landuse = landuse_sgp,
                                     match_buildings_pop = 'closest')


# perform dasymetric mapping on selected year (2020)
popdens_raster <- pop_dasymap(pop_polygons = pop_rasters$pop_polygons[[2]],
                              pop_perblock_count = pop_rasters$pop_count[[2]],
                              pop_perblock_density = pop_rasters$pop_density[[2]],
                              land_relative_density = buildings_rasters[[2]],
                              filename = 'buildings_popdensity.tif',
                              wopt = list(gdal=c('COMPRESS=LZW')))


# finally, convert to population count per building polygon
pop_density_polygonise(input_raster = popdens_raster,
                       write = TRUE,
                       dsn = 'buildings_popcount.geojson')
}

}
