% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parks_calc_attributes.R
\name{parks_calc_attributes}
\alias{parks_calc_attributes}
\title{Calculate attributes per park polygon based on supplied data}
\usage{
parks_calc_attributes(
  parks,
  data_points = list(),
  data_lines = list(),
  data_rasters = list(),
  rasters_summarise_fun = NULL,
  raster_min_patch_size = units::set_units(0, "m^2"),
  raster_edge = NULL,
  relative = TRUE,
  filename = NULL,
  ...
)
}
\arguments{
\item{parks}{\code{sf} polygons (with projected coordinate reference system).}

\item{data_points}{Named list of \code{sf} object(s) containing data of geometry type \code{POINT} or \code{MULTIPOINT}.
List names are used to name the park attributes (columns) in the output.}

\item{data_lines}{Named list of \code{sf} object(s) containing data of geometry type \code{LINESTRING} or \code{MULTILINESTRING}.
List names are used to name the park attributes (columns) in the output.}

\item{data_rasters}{Named list of single \code{SpatRaster} object(s) from \code{terra::rast()}.
List names are used to name the park attributes (columns) in the output.}

\item{rasters_summarise_fun}{Function to summarise the raster data passed to \code{terra::extract()}.
Defaults to \code{NULL}, which tabulates the sum of each unique value in the raster (i.e. classified raster,
with numbers each representing a specific class/category) using the function \code{raster_class_area()}.}

\item{raster_min_patch_size}{Minimum patch size to be included when tabulating the sum of each raster class.
Only relevant if \code{rasters_summarise_fun = NULL}. Provided either as a units object (see \code{units::set_units()}),
or a number in the units of the coordinate reference system. Defaults to \code{0} m^2.}

\item{raster_edge}{numeric. Option to calculate total edge length of (classified) raster(s)
associated with each of the \code{parks} polygons, using the function \code{raster_edge_length()}. The total edge length of raster patches contained \href{https://postgis.net/docs/ST_Within.html}{within}
\code{parks} will be calculated, and patches in close proximity can be included by increasing the value of this argument;
the length of \code{parks} borders that \href{https://postgis.net/docs/ST_Intersection.html}{intersect} the buffered raster will be calculated.
This provides a way include patches in close proximity to the \code{parks} (e.g. total waterfront length close to parks).
Note that each class (unique value in the raster) will be summarised, including \code{0}; convert pixels to \code{NA} if you wish to exclude them.
Provided either as a units object (see \code{units::set_units()}),
or a number in the units of the coordinate reference system. Defaults to \code{NULL} (not calculated). Set to \code{0} to include patches
\href{https://postgis.net/docs/ST_Within.html}{within} \code{parks} only.}

\item{relative}{logical. Whether or not to calculate relative amounts
(e.g. point density, ratio of line-to-perimeter length, proportional area). Defaults to \code{TRUE}.}

\item{filename}{character (optional). File path to export output data (GeoJSON format).}

\item{...}{Other arguments passed to \code{terra::extract()}.}
}
\value{
\code{parks} with added columns containing the summaries of basic park attributes
(area and perimeter), as well as summaries of each of the supplied datasets.
The summary method depends on geometry type (i.e. points, lines or rasters) and supplied arguments.
Some examples:
\describe{
\item{area}{Area of park polygon.}
\item{perimeter}{Perimeter of park polygon.}
\item{< object name in \code{data_points} >_count}{Total count of points within park polygon.}
\item{< object name in \code{data_points} >_ptdensity}{Total count divided by area of the park polygon (point density).
Included if argument \code{relative} set to \code{TRUE}.}
\item{< object name in \code{data_lines} >_length}{Sum of line lengths within park polygon.}
\item{< object name in \code{data_lines} >_length_perim_ratio}{Ratio of line-to-perimeter length of the park polygon.
Included if argument \code{relative} set to \code{TRUE}.}
\item{< object name in \code{data_rasters} >}{Summarised values of a specific raster class
(depends on function provided in the \code{rasters_summarise_fun} argument).}
\item{< object name in \code{data_rasters} >< class value >_area}{Total area of a specific raster class
(if \code{rasters_summarise_fun = NULL}).}
\item{< object name in \code{data_rasters} >< class value >_area_pct}{Percentage area of a specific raster class
(if \code{rasters_summarise_fun = NULL}). Included if argument \code{relative} set to \code{TRUE}.}
\item{< object name in \code{data_rasters} >< class value >_length}{Total edge length of a specific raster class.}
\item{< object name in \code{data_rasters} >< class value >_length_perim_ratio}{Edge-to-perimeter length of a specific raster class.
Included if argument \code{relative} set to \code{TRUE}.}
}
}
\description{
Summaries will be calculated for each of the supplied datasets (\code{data_points}, \code{data_lines}, or \code{data_rasters})
and appended to the \code{parks} data as additional columns.
Ensure that all have a (projected) coordinate reference system similar to \code{parks}.
}
\examples{
\dontrun{
parks_sgp <- data(parks_sgp) # park polygons

# get playground points first
city_boundaries <- data(singapore) \%>\%
   dplyr::filter(year == 2020) \%>\%
   sf::st_union() \%>\%
   sf::st_as_sf() \%>\%
   smoothr::fill_holes(threshold = units::set_units(1, 'km^2'))  \%>\%
   smoothr::drop_crumbs(threshold = units::set_units(1, 'km^2'))  \%>\%
   sf::st_make_valid()

playgrounds <- get_playgrounds_osm(place = city_boundaries,
                                   date = as.Date('2021-01-01'))
point_list <- list(playgrounds) # convert to list (can add other point data too)
names(point_list) <- c("playground") # name each element in list


# point count & density per park
parks_calc_attributes(parks = parks_sgp,
                      data_points = point_list,
                      relative = TRUE)
}

}
